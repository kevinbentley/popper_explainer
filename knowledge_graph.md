# Knowledge Graph Implementation

This document describes the knowledge graph implementation in the Popper Explainer system. The graph represents laws, theorems, failure patterns, and their relationships to support Popperian-style scientific discovery.

## Architecture Overview

The knowledge graph is implemented as an **implicit graph** using SQLite with JSON-embedded relationships, rather than a traditional graph database. This design provides:

- Durable persistence for long-running discovery sessions
- Resume capability after interruption
- Relational queries with graph-like traversal via JOINs and embedded JSON

The graph has three layers:
1. **Facts Layer** - Laws verified through testing (PASS/FAIL/UNKNOWN)
2. **Synthesis Layer** - Theorems that combine multiple laws into explanations
3. **Clustering Layer** - Failure clusters that group similar failure patterns

---

## Node Types

### Laws

Laws are the foundational nodes representing falsifiable claims about the simulated universe. Each law goes through testing and receives a verdict.

**Key attributes:**
- `law_id` - Unique identifier (e.g., "law_001")
- `law_hash` - Content hash for deduplication
- `template` - Claim template type (invariant, monotone, implication_step, etc.)
- `law_json` - Full serialized CandidateLaw object
- Status determined by most recent evaluation: PASS, FAIL, or UNKNOWN

**Source:** `LawRecord` in `src/db/models.py`, stored in `laws` table

### Evaluations

Evaluation nodes capture each testing attempt for a law, including the verdict and evidence.

**Key attributes:**
- `law_id` - Foreign key to the tested law
- `status` - Verdict: PASS, FAIL, or UNKNOWN
- `reason_code` - Explanation for UNKNOWN verdicts
- `power_metrics_json` - Statistical power of the test
- `vacuity_json` - Whether the test was non-trivial

**Source:** `EvaluationRecord` in `src/db/models.py`, stored in `evaluations` table

### Counterexamples

Counterexamples are minimal reproduction packages for FAIL verdicts. They serve as evidence nodes.

**Key attributes:**
- `initial_state` - Starting state that leads to failure
- `t_fail` - Timestep where violation occurs
- `trajectory_excerpt_json` - Relevant state sequence
- `witness_json` - Structured witness data

**Source:** `CounterexampleRecord` in `src/db/models.py`, stored in `counterexamples` table

### Theorems

Theorems are synthesized explanations that combine multiple laws. They are generated by an LLM from law snapshots.

**Key attributes:**
- `name` - Human-readable theorem name
- `status` - Confidence level: Established, Conditional, or Conjectural
- `claim` - The theorem statement
- `support_json` - Array of LawSupport objects linking to laws (see Edges below)
- `failure_modes` - Known ways the theorem could fail
- `missing_structure` - Observables or definitions needed
- `bucket_tags` - Multi-label failure category assignment

**Source:** `Theorem` dataclass in `src/theorem/models.py`, stored in `theorems` table

### Failure Clusters

Failure clusters group theorems with similar failure signatures into semantic communities.

**Key attributes:**
- `cluster_id` - Deterministic ID based on content hash
- `bucket_tags` - Multi-label bucket assignment
- `theorem_ids` - List of theorem IDs in this cluster
- `centroid_signature` - Representative failure signature
- `top_keywords` - TF-IDF extracted terms
- `recommended_action` - SCHEMA_FIX, OBSERVABLE, or GATING

**Source:** `FailureCluster` dataclass in `src/theorem/models.py`, stored in `failure_clusters` table

### Observable Proposals

Observable proposals are suggested new measurements to address failure patterns. They link clusters to actionable improvements.

**Key attributes:**
- `cluster_id` - Foreign key to the failure cluster
- `observable_name` - Proposed observable name
- `observable_expr` - Expression definition
- `priority` - high, medium, or low
- `action_type` - SCHEMA_FIX, OBSERVABLE, or GATING

**Source:** `ObservableProposal` dataclass in `src/theorem/models.py`, stored in `observable_proposals` table

---

## Edge Types

### Law → Evaluation (Testing Edge)

Each law can have multiple evaluations over time. The relationship is one-to-many via `law_id` foreign key.

**Query pattern:** `evaluations.law_id → laws.law_id`

### Evaluation → Counterexample (Evidence Edge)

FAIL evaluations have associated counterexamples. The relationship is one-to-one or one-to-many via `evaluation_id` foreign key.

**Query pattern:** `counterexamples.evaluation_id → evaluations.id`

### Theorem → Law (Support Edge)

Theorems reference supporting laws via embedded JSON. Each support relationship has a **typed role**:

- **CONFIRMS** - Law provides positive evidence for the theorem
- **CONSTRAINS** - Law limits the theorem's applicability
- **REFUTES_ALTERNATIVE** - Law eliminates competing explanations

The `LawSupport` dataclass encodes this:
```
LawSupport:
  law_id: str
  role: SupportRole  # CONFIRMS | CONSTRAINS | REFUTES_ALTERNATIVE
```

**Storage:** `theorems.support_json` contains array of serialized LawSupport objects

### Theorem → Failure Cluster (Clustering Edge)

Theorems are assigned to failure clusters based on signature similarity. The relationship is stored as a list of theorem IDs in the cluster.

**Storage:** `failure_clusters.theorem_ids_json` contains array of theorem IDs

### Failure Cluster → Observable Proposal (Recommendation Edge)

Clusters link to proposed observables that could address their failure patterns.

**Query pattern:** `observable_proposals.cluster_id → failure_clusters.cluster_id`

---

## Failure Bucket Taxonomy

Theorems are assigned to one or more failure buckets based on keyword matching. The buckets represent categories of failure:

| Bucket | Description | Keywords |
|--------|-------------|----------|
| DEFINITION_GAP | Missing or ambiguous definitions | definition, precise, undefined, ambiguous |
| COLLISION_TRIGGERS | Collision or trigger-related failures | collision, trigger, converging, bound |
| LOCAL_PATTERN | Configuration and spatial patterns | adjacent, configuration, local, pattern |
| EVENTUALITY | Long-term or asymptotic behaviors | eventually, asymptotic, converge, steady |
| MONOTONICITY | Monotonic trend violations | monotonic, increasing, decreasing, trend |
| SYMMETRY | Symmetry and invariance issues | symmetric, mirror, reflection, commute |
| OTHER | Default bucket for uncategorized | (fallback) |

The bucket determines the **recommended action**:
- DEFINITION_GAP alone → SCHEMA_FIX
- LOCAL_PATTERN or COLLISION_TRIGGERS → OBSERVABLE
- EVENTUALITY → GATING

---

## Clustering Algorithm

The system uses a two-pass clustering algorithm:

### Pass A: Multi-Label Bucket Assignment

Each theorem's failure signature is matched against bucket keywords. A theorem can belong to multiple buckets.

Implementation: `MultiLabelBucketAssigner.assign_all()` in `src/theorem/clustering.py`

### Pass B: TF-IDF + Agglomerative Clustering

Within each bucket, theorems are clustered using:
1. TF-IDF vectorization of failure signatures
2. Cosine distance matrix computation
3. Agglomerative clustering with average linkage
4. Distance threshold default: 0.6

Implementation: `TfidfClusterer.cluster_bucket()` in `src/theorem/clustering.py`

### Cluster ID Generation

Cluster IDs are deterministic, computed from bucket name, index, and content hash:
```
fc_{bucket}_{idx}_{sha256(sorted_theorem_ids)[:8]}
```

This ensures reproducibility across runs.

---

## Signature Building

Failure signatures are text representations of a theorem's failure characteristics, used for clustering.

### Basic Signature

Concatenates normalized failure_modes and missing_structure text.

Implementation: `build_failure_signature()` in `src/theorem/signature.py`

### Role-Coded Signature (PHASE-D)

Encodes support roles and missing structure types as prefixed tokens:
- `C:law_001` - Confirms law
- `X:law_002` - Constrains law
- `DEF:observable` - Definition missing
- `LOC:pattern` - Local structure missing
- `TMP:behavior` - Temporal structure missing
- `MEC:process` - Mechanism missing
- `FM:mode` - Failure mode keyword

Implementation: `build_role_coded_signature()` in `src/theorem/signature.py`

---

## Database Schema

### Primary Tables

| Table | Purpose |
|-------|---------|
| `laws` | Candidate laws with claims |
| `evaluations` | Test results for laws |
| `counterexamples` | Minimal repro packages for FAIL |
| `theorems` | Synthesized explanations |
| `failure_clusters` | Grouped failure signatures |
| `observable_proposals` | Suggested new observables |

### Relationship Tables

| Table | Purpose |
|-------|---------|
| `theorem_runs` | Batch tracking for theorem generation |
| `failure_keys` | Canonical counterexample patterns |
| `counterexample_failure_keys` | Links counterexamples to patterns |

### Reproducibility Tables

| Table | Purpose |
|-------|---------|
| `theorem_generation_artifacts` | LLM call capture |
| `cluster_artifacts` | Clustering run capture |
| `law_witnesses` | Structured FAIL witnesses |

### Foreign Key Relationships

```
laws
├── evaluations (law_id)
│   └── counterexamples (evaluation_id)
│       └── counterexample_failure_keys (counterexample_id)
└── law_novelty (law_id)

theorem_runs
├── theorems (theorem_run_id)
├── failure_clusters (theorem_run_id)
└── observable_proposals (theorem_run_id)

theorem_generation_artifacts
└── theorem_runs (artifact_id)
```

---

## Key Classes

### Domain Models (`src/theorem/models.py`)

| Class | Role |
|-------|------|
| `Theorem` | Synthesized explanation with support links |
| `LawSupport` | Typed edge from theorem to law |
| `SupportRole` | Enum: CONFIRMS, CONSTRAINS, REFUTES_ALTERNATIVE |
| `FailureCluster` | Grouped failure pattern |
| `ObservableProposal` | Suggested measurement |
| `TheoremStatus` | Enum: Established, Conditional, Conjectural |
| `FailureBucket` | Enum: DEFINITION_GAP, COLLISION_TRIGGERS, etc. |
| `MissingStructureType` | Typed missing structure category |
| `LawSnapshot` | Input representation for theorem generation |

### Clustering (`src/theorem/clustering.py`)

| Class | Role |
|-------|------|
| `TwoPassClusterer` | Main clustering orchestrator |
| `MultiLabelBucketAssigner` | Pass A: Keyword-based bucket tagging |
| `TfidfClusterer` | Pass B: TF-IDF + Agglomerative clustering |
| `ClusterActionMapper` | Maps buckets to recommended actions |

### Signatures (`src/theorem/signature.py`)

| Function | Role |
|----------|------|
| `build_failure_signature()` | Basic normalized signature |
| `build_role_coded_signature()` | Role-prefixed signature for precision clustering |
| `hash_signature()` | SHA256 hash for indexing |
| `extract_key_terms()` | Term extraction for Jaccard similarity |

### Generation (`src/theorem/generator.py`)

| Class | Role |
|-------|------|
| `TheoremGenerator` | Orchestrates LLM-based theorem synthesis |
| `TheoremGeneratorConfig` | Configuration for generation |
| `LLMClient` | Protocol for LLM backends |

### Persistence (`src/db/repo.py`)

| Class | Role |
|-------|------|
| `Repository` | Main database access layer |

---

## Graph Traversal Patterns

### Finding Evidence for a Theorem

```
theorem → support_json → [LawSupport] → law_id → laws → evaluations → counterexamples
```

### Finding All Theorems in a Cluster

```
failure_clusters.theorem_ids_json → [theorem_id] → theorems
```

### Finding Actions for a Failure Pattern

```
theorems → failure_clusters → observable_proposals
```

### Tracking Law Status Changes

```
laws → evaluations (ordered by created_at) → status history
```

### Finding Related Counterexamples

```
counterexamples → counterexample_failure_keys → failure_keys → other counterexamples
```

---

## Phase Evolution

The knowledge graph has evolved through implementation phases:

| Phase | Features Added |
|-------|----------------|
| PHASE-C | Multi-label bucket assignment, TF-IDF clustering, keyword extraction, action mapping |
| PHASE-D | Typed missing structure, role-coded signatures, theorem generation artifacts |
| PHASE-E | Deterministic cluster IDs, witness capture, signature versioning |

---

## Usage Notes for Agents

1. **Always check law status** before using in theorem synthesis - only PASS and FAIL laws have reliable evidence

2. **Cluster IDs are content-based** - the same set of theorems will always produce the same cluster ID

3. **Support roles matter** - CONSTRAINS laws are more diagnostic for failures than CONFIRMS laws

4. **Bucket tags are multi-label** - a theorem can belong to multiple failure categories

5. **Observable proposals have priorities** - high priority proposals address more impactful gaps

6. **Signature version tracking** - check `signature_version` before comparing signatures from different runs
